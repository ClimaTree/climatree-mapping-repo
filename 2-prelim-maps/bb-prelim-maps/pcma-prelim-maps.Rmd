---
title: "PCMA Preliminary Maps"
subtitle: "Preliminary maps and spatial analysis for Picea mariana"
author: "Briana Barajas"
date: "`r Sys.Date()`"
---

## Preparation

```{r}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```

```{r libs}
library(tidyverse)
library(here)

library(sf)     # vector data
library(terra)  # raster data
library(tmap)   # mapping

library(tidyr) # additional packages from 4a. First stage.R
library(dbplyr)
library(broom.mixed)
library(broom)
library(purrr)
library(fixest)
library(dtplyr)
library(furrr)
```

## Load Data

```{r set-wdir}
# create tsosie file path
remote_wdir <- here("~", "..", "..", "capstone", "climatree")
```


```{r read-data}
## ===========================================
##          PCMA Dendrochronologies       ----
## ===========================================

# read in data
pcma_dendro <- read_csv(here(remote_wdir, "output-data", "step-1-output", "pcma_rwi.csv")) %>% 
  select(-core_id)

# combine multiple cores from the same tree
pcma_dendro <- pcma_dendro %>% 
  lazy_dt() %>% #lazy df only performs computations as requested, decrease comp time
  
  group_by(collection_id, tree, year) %>% # grouping to combine multiple cores from same tree
  
  summarise(rwi = mean(rwi), .groups = "drop") %>% # calculate mean rwi
  
  as_tibble() #convert back to standard df type
  
## ===========================================
##      Historic site-level climate       ----
## ===========================================

# read in data
an_site_clim <- read_csv(gzfile(here(remote_wdir, "output-data", "step-1-output", "site_an_clim.gz")))

# join site_clim and dendro data
pcma_dendro <- pcma_dendro %>% 
  left_join(an_site_clim, by = c("collection_id", "year"))

## ===========================================
##            Site information            ----
## ===========================================
# read in data
site_smry <- read_csv(here(remote_wdir, "dataverse-archive", "site_summary.csv"))

# clean colnames
site_smry <- site_smry %>% 
  select(collection_id, sp_id) %>% 
  mutate(species_id = tolower(sp_id)) %>% 
  select(-sp_id)

# join data
pcma_dendro <- pcma_dendro %>% 
  left_join(site_smry, by = "collection_id")

## ===========================================
##       Remove spp w.out range maps      ----
## ===========================================
# waiting for update on clim_niche_=.csv
```


```{r explr-data, eval=FALSE}
## ==================================================
##                 PCMA range map                ----
## ==================================================

# define query for pcma range
query <- "SELECT * FROM merged_ranges_dissolve WHERE sp_code='pcma' "

# read in pcma geometry data
pcma_range <- st_read(here(remote_wdir, "dataverse-archive",  "merged_ranges_dissolve.shp"), query = query) %>% 
  st_make_valid()

# plot pcma range
tm_shape(pcma_range) +
  tm_polygons()
```


```{r, eval=FALSE}
## ===========================================
##       Existing site-level regression   ----
## ===========================================
# bb - this is site level data, so using the collection_id
fs_mod <- function(site_data, outcome = "rwi", energy_var = "pet.an", mod_type = "lm"){
  
  failed <- F
  reg_error <- NA
  nobs <- NA
  ntrees <- site_data %>% select(tree) %>%  n_distinct()
  no_cwd_var <- (site_data %>% select(cwd.an) %>% n_distinct() == 1)
  no_pet_var <- (site_data %>% select(energy_var) %>% n_distinct() == 1)

  if (no_cwd_var | no_pet_var) {
    message(paste0("Site has no variation in cwd.an or ", energy_var))
    failed <- T
  } else{
    
    # Try to run felm. Typically fails if missing cwd / pet data
    # bb - two formula choices, lm or lme
    tryCatch(
      expr = {
        formula <- as.formula(paste0(outcome, " ~ ", energy_var, " + cwd.an")) #bb-define model/formula
        if (mod_type == "lm"){
          mod <- lm(formula, data = site_data) ##bb-simple model type
        }
        if (mod_type == "lme"){ #bb-ml model type 
          mod <- nlme::lme(formula,
                           data=site_data, method="REML",
                           random = ~ 1 | tree,
                           correlation = nlme::corAR1(form=~year|tree)) ## bb - controls for autocorrelation
        }
        
        mod_sum <- summary(mod) # bb - specific values from this pulled out in next step
        mod_vcov <- vcov(mod) # bb - pull out covariance matrix for second stage
        # cov <- list(int_cwd = mod_vcov[1, 2], 
        #             int_pet = mod_vcov[1, 3], 
        #             pet_cwd = mod_vcov[2, 3])
        nobs <- nobs(mod)
        mod <- tidy(mod) %>%
          mutate(term = term %>% str_replace("\\(Intercept\\)", "intercept")) %>% 
          filter(term %in% c('intercept', 'cwd.an', energy_var)) %>% 
          pivot_wider(names_from = "term", values_from = c("estimate", "std.error", "statistic", "p.value"))
        # mod <- mod %>% 
        #   rename_all(funs(stringr::str_replace_all(., energy_var, 'energy.an')))
        mod$cov_int_cwd = mod_vcov[c("(Intercept)"), c("cwd.an")]
        cov_var_name <- paste0("cov_int_", energy_var %>% str_replace(".an", ""))
        mod[[cov_var_name]] = mod_vcov[c("(Intercept)"), c(energy_var)]
        cov_var_name <- paste0("cov_cwd_", energy_var %>% str_replace(".an", ""))
        mod[[cov_var_name]] = mod_vcov[c("cwd.an"), c(energy_var)]
        mod$r2 = mod_sum$r.squared
      },
      error = function(e){ 
        message("Returned regression error")
        reg_error <<- e[1]
        failed <<- T
      }
    )    
  }
  if (failed){
    return(NA)
  }
  return(tibble(mod = list(mod), nobs = nobs, ntrees = ntrees, error = reg_error))
}

```

